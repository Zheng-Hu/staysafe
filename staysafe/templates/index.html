"""
StaySafe index view.
URLs include:
/
"""
import flask
from flask import session, request
import arrow
import staysafe
import logging
import sys
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger('werkzeug')


@staysafe.app.route('/', methods=['GET', 'POST'])
def show_index():
    # if flask.request.method == 'POST':
    #     return flask.redirect(flask.url_for('show_Duder'))
    # return flask.render_template("main.html")
    # Get to database

    print('show index', file=sys.stdout)
    sys.stdout.flush()

    connection = staysafe.model.get_db()
    # if flask.request.method == 'POST':
    # specific: search a certain building FRONTEND-FIXME
    # if "specific" in request.form:
    if request.method == 'POST':    
        #staysafe.app.logger.info('testing info log')
        form = flask.request.form['buildingname']
        building_info = connection.execute("SELECT id, building_name "
                                            "FROM buildings WHERE building_name=?",
                                            (flask.request.form['building'],))
        # general: search a group of buildings FRONTEND-FIXME
        # if "general" in request.form:
        # will develop in beta release FIXME
        time_info = connection.execute("SELECT cong_level "
                                        "FROM congestion WHERE owner_id=? "
                                        "AND day_of_week=? "
                                        "AND time_period=?",
                                        (building_info["id"],
                                        flask.request.form["day_of_week"],
                                        flask.request.form["time_period"],))

        # FRONTEND-FIXME: templates need to use the exactly same names to fetch the info
        context = {"building_name": building_info["building_name"],
                    "day_of_week": time_info["day_of_week"],
                    "time_period": time_info["time_period"]}
        print('jump predict', file=sys.stdout)
        return flask.render_template("predict.html", **context)
    else:
        return flask.render_template("index.html")
    return flask.render_template("index.html")

#@staysafe.app.route('/predict.html', methods=['GET', 'POST'])
#def signup():
#    return flask.render_template('predict.html')

@staysafe.app.route('/Duder/', methods=['GET', 'POST'])
def show_Duder():
    return flask.render_template("DuderLibrary.html")

@staysafe.app.route('/predict.html', methods=['GET', 'POST'])
#FIX-ME
def show_Predict():
    # Get to database
    print('show predict', file=sys.stdout)
    sys.stdout.flush()

    connection = staysafe.model.get_db()
    cur = connection.cursor() 
    if flask.request.method == 'POST':
        # specific: search a certain building FRONTEND-FIXME
        building_info = connection.execute("SELECT id, building_name "
                                                "FROM buildings WHERE building_name=?",
                                                (flask.request.form['building'],))
        
        print(cur.fetchall(), file=sys.stdout)
        sys.stdout.flush()

        # general: search a group of buildings FRONTEND-FIXME
        # if "general" in request.form:
        # will develop in beta release FIXME
        time_info = connection.execute("SELECT cong_level "
                                        "FROM congestion WHERE owner_id=? "
                                        "AND day_of_week=? "
                                        "AND time_period=?",
                                        (80,#building_info["id"],
                                        3,#flask.request.form["day_of_week"],
                                        15,))#flask.request.form["time_period"],))

        # FRONTEND-FIXME: templates need to use the exactly same names to fetch the info
        context = {"building_name": building_info["building_name"],
                    "day_of_week": 3, #time_info["day_of_week"],
                    "time_period": 15} #time_info["time_period"]}

        #print(context, file=sys.stderr)
        return flask.render_template("predict.html", **context)
